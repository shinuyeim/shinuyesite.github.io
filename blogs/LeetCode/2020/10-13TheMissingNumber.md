---
title: 剑指Offer 53 - || 0 ~ n-1中缺失的数字
date: 2020-10-13
tags:
 - 简单
 - 力扣
categories:
 - 算法笔记
---


## 题目描述

一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

### 示例1:
::: tip
输入：[0,1,3] 
输出：2 
:::

### 示例2:
::: tip
输入：[0,1,2,3,4,5,6,7,9]  
输出：8
:::

### 限制
1 <= 数组长度 <= 10000

## 题目分析
输入的数最小为0，数组长度最小为0，并且数组内的数字都是0~n-1的范围内递增且唯一的。所有我们可以知道，当数组长度为1是，数组内的元素是唯一确定的也就是0。其实需要找到数组中的不存在的元素就是找到数组元素与下标(数组的位置)不同时就是不存在的那个元素，就是当a[m] != 时。

### 算法设计
采用二分法查找，可以节省很多搜索时间。
例如有数组a[5] = {0, 1, 2, 3, 5}。 先设m = (i + j) / 2。则m等于2，判断a[2] == 2，则可以证明，在a[2]前面的元素数组下标与元素值对应，因为如果缺少一个，因为数组时递增，且元素不重复，则到a[2]时就不可能有a[2] == 2，这样就很简单，当a[m] == m 时，就往a[m]后面继续查找，当a[m] != m 时就证明在a[m]前面就有缺失的元素，这是第一步。
第二步就是当第一步确定了需要在数组的左边半边还是右半边查找，当要在左边查找时，令 j = m-1;需要在右边查找时，令 i = m+1;直到找出结束。
::: tip
i和j分别代表数组的左右下标
:::


### 代码 
```java
class Solution {
    public int missingNumber(int[] nums) {
        int i = 0, j = nums.length - 1;
        while(i <= j) {
            int m = (i + j) / 2;
            if(nums[m] == m) i = m + 1;
            else j = m - 1;
        }
        return i;
    }
}
```