---
title: 寻找旋转排序数组中的最小值
date: 2020-10-20
tags:
 - 简单
 - 力扣
categories:
 - 算法笔记
---


## 题目描述

假设按照升序排序的数组在预先未知的某个点上进行了旋转。
( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。  
请找出其中最小的元素。  
你可以假设数组中不存在重复元素。

### 示例1:
::: tip
输入: [3,4,5,1,2]
输出: 1
:::

### 示例2:
::: tip
输入: [4,5,6,7,0,1,2]
输出: 0
:::


## 题目分析
这是一个特殊处理的排序的数组，从某一个位置截取一部分到原数组的末尾。原数组是升序有序的数组我们暂时设为a数组赋值为[1,  2, 3, 4, 5, 6, 7]，如果数组没有旋转，数组的前一位总是小于后一位。因为数组是升序且没有重复元素的。我们只需判断数组的第一个元素和最后一个元素的大小关系，就可以判断出数组是否是旋转数组。设数组的第一位元素序列为left，最后一位元素序列为right，若a[left] < a[right]，则证明数组没有旋转，则第一个数字就是最小的值，若a[left] > a[right]，则表明数组旋转了。在旋转数组中我们可以寻找到一个变化的点， 我们称这个点为变化点。
::: tip
变化点左侧的元素 > 数组的第一个元素
变化点右侧的元素 < 数组的第一个元素
:::

### 算法设计
> + 找到数组的中间元素 mid。

> + 如果中间元素 > 数组第一个元素，我们需要在 mid 右边搜索变化点。

> + 如果中间元素 < 数组第一个元素，我们需要在 mid 左边搜索变化点。

> + 当我们找到变化点时停止搜索，当以下条件满足任意一个即可：
  > >  nums[mid] > nums[mid + 1]，因此 mid+1 是最小值。

  > >   nums[mid - 1] > nums[mid]，因此 mid 是最小值。


### 代码 
```C
int findMin(int* nums, int numsSize){
    
    if (numsSize == 1) {
      return nums[0];
    }

    int left = 0, right = numsSize - 1;

    if (nums[right] > nums[0]) {
      return nums[0];
    }
    
    while (right >= left) {
      int mid = left + (right - left) / 2;

      if (nums[mid] > nums[mid + 1]) {
        return nums[mid + 1];
      }

      if (nums[mid - 1] > nums[mid]) {
        return nums[mid];
      }
      if (nums[mid] > nums[0]) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    return -1;
}
```

### 时间复杂度
时间复杂度和二分法一样同为O(logn)。