"use strict";(self.webpackChunkafternoon_grocery_store=self.webpackChunkafternoon_grocery_store||[]).push([[7766],{7126:(n,a,e)=>{e.r(a),e.d(a,{data:()=>s});const s={key:"v-bf6c97de",path:"/blogs/LanQiao/TheSecondSimulationOfThe11thLanQiaoCup.html",title:"第十一届蓝桥杯大赛第二次模拟",lang:"zh-CN",frontmatter:{title:"第十一届蓝桥杯大赛第二次模拟",date:"2021-03-01T00:00:00.000Z",tags:["蓝桥杯"],categories:["竞赛真题"]},excerpt:"",headers:[{level:2,title:"题目",slug:"题目",children:[]},{level:2,title:"1. 12.5MB",slug:"_1-12-5mb",children:[{level:3,title:"问题描述",slug:"问题描述",children:[]},{level:3,title:"题解",slug:"题解",children:[]}]},{level:2,title:"2. 最多边数",slug:"_2-最多边数",children:[{level:3,title:"题解",slug:"题解-1",children:[]}]},{level:2,title:"3. 单词排列",slug:"_3-单词排列",children:[{level:3,title:"问题描述",slug:"问题描述-1",children:[]},{level:3,title:"题解",slug:"题解-2",children:[]}]},{level:2,title:"4. 括号序列",slug:"_4-括号序列",children:[{level:3,title:"问题描述",slug:"问题描述-2",children:[]},{level:3,title:"题解",slug:"题解-3",children:[]}]},{level:2,title:"5. 反倍数",slug:"_5-反倍数",children:[{level:3,title:"问题描述",slug:"问题描述-3",children:[]},{level:3,title:"思路",slug:"思路",children:[]},{level:3,title:"源代码",slug:"源代码",children:[]}]},{level:2,title:"6. 凯撒加密",slug:"_6-凯撒加密",children:[{level:3,title:"问题描述",slug:"问题描述-4",children:[]},{level:3,title:"思路",slug:"思路-1",children:[]},{level:3,title:"源代码",slug:"源代码-1",children:[]}]},{level:2,title:"7. 螺旋",slug:"_7-螺旋",children:[{level:3,title:"问题描述",slug:"问题描述-5",children:[]},{level:3,title:"思路",slug:"思路-2",children:[]},{level:3,title:"源代码",slug:"源代码-2",children:[]}]}],git:{createdTime:1642079704e3,updatedTime:1642079704e3,contributors:[{name:"shinuyeim",email:"shinuyemail@gmail.com",commits:1}]}}},73:(n,a,e)=>{e.r(a),e.d(a,{default:()=>l});const s=(0,e(6252).uE)('<h2 id="题目" tabindex="-1"><a class="header-anchor" href="#题目" aria-hidden="true">#</a> 题目</h2><h2 id="_1-12-5mb" tabindex="-1"><a class="header-anchor" href="#_1-12-5mb" aria-hidden="true">#</a> 1. 12.5MB</h2><h3 id="问题描述" tabindex="-1"><a class="header-anchor" href="#问题描述" aria-hidden="true">#</a> 问题描述</h3><p>【问题描述】<br>在计算机存储中，12.5MB是多少字节？<br>【答案提交】<br>这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。<br><br><br><br></p><h3 id="题解" tabindex="-1"><a class="header-anchor" href="#题解" aria-hidden="true">#</a> 题解</h3><p>在计算机存储中，1MB = 1024KB ，1KB = 1024字节，12.5MB = 12.5 * 1024 * 1024 字节 = 13,107,200字节。</p><h4 id="答案" tabindex="-1"><a class="header-anchor" href="#答案" aria-hidden="true">#</a> 答案</h4><p>13107200</p><h2 id="_2-最多边数" tabindex="-1"><a class="header-anchor" href="#_2-最多边数" aria-hidden="true">#</a> 2. 最多边数</h2><p>【问题描述】<br>一个包含有2019个结点的有向图，最多包含多少条边？（不允许有重边）<br>【答案提交】<br>这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。<br><br><br></p><h3 id="题解-1" tabindex="-1"><a class="header-anchor" href="#题解-1" aria-hidden="true">#</a> 题解</h3><p>最多边数问题属于图论的内容，有公式，如果想不起公式的话可以自己找规律。最小的图像就是三角形，三角形有 6 条有向边，四边形有 12 条有向边，五边形有 20 条有向边，所以我们能够看出，有向图的边数为 n * n-1，所以有2019个节点的有向图最多有2019 * 2018 = 4,074,342条边。</p><h4 id="答案-1" tabindex="-1"><a class="header-anchor" href="#答案-1" aria-hidden="true">#</a> 答案</h4><p>4074342</p><h2 id="_3-单词排列" tabindex="-1"><a class="header-anchor" href="#_3-单词排列" aria-hidden="true">#</a> 3. 单词排列</h2><h3 id="问题描述-1" tabindex="-1"><a class="header-anchor" href="#问题描述-1" aria-hidden="true">#</a> 问题描述</h3><p>【问题描述】<br>将LANQIAO中的字母重新排列，可以得到不同的单词，如LANQIAO、AAILNOQ等，注意这7个字母都要被用上，单词不一定有具体的英文意义。<br>请问，总共能排列如多少个不同的单词。<br>【答案提交】<br>这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。<br><br><br></p><h3 id="题解-2" tabindex="-1"><a class="header-anchor" href="#题解-2" aria-hidden="true">#</a> 题解</h3><p>全排列问题，总共有7个字母，其中有一个字母是重复的，所以排列情况为，7 * 6 * 5 * 4 * 3 * 2 * 1 / 2 = 2520</p><h4 id="答案-2" tabindex="-1"><a class="header-anchor" href="#答案-2" aria-hidden="true">#</a> 答案</h4><p>2520</p><h2 id="_4-括号序列" tabindex="-1"><a class="header-anchor" href="#_4-括号序列" aria-hidden="true">#</a> 4. 括号序列</h2><h3 id="问题描述-2" tabindex="-1"><a class="header-anchor" href="#问题描述-2" aria-hidden="true">#</a> 问题描述</h3><p>【问题描述】<br>由1对括号，可以组成一种合法括号序列：()。<br>由2对括号，可以组成两种合法括号序列：()()、(())。<br>由4对括号组成的合法括号序列一共有多少种？<br>【答案提交】<br>这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。<br><br><br></p><h3 id="题解-3" tabindex="-1"><a class="header-anchor" href="#题解-3" aria-hidden="true">#</a> 题解</h3><p>有效括号配对问题，熟悉卡特兰数的应该对这题很敏感，卡特兰数接下来我会花一篇博客稍微总结复习一下，这里只是提一个大概吧：卡特兰数是形如：1，1， 2， 5， 14…这样的数。我们现在只需要知道，1对括号可以组成1种合法序列，2对有2种，3对有5种，4对其实就是14种。</p><h4 id="答案-3" tabindex="-1"><a class="header-anchor" href="#答案-3" aria-hidden="true">#</a> 答案</h4><p>14</p><h2 id="_5-反倍数" tabindex="-1"><a class="header-anchor" href="#_5-反倍数" aria-hidden="true">#</a> 5. 反倍数</h2><h3 id="问题描述-3" tabindex="-1"><a class="header-anchor" href="#问题描述-3" aria-hidden="true">#</a> 问题描述</h3><p>【问题描述】<br> 给定三个整数 a, b, c，如果一个整数既不是 a 的整数倍也不是 b 的整数倍还不是 c 的整数倍，则这个数称为反倍数。<br> 请问在 1 至 n 中有多少个反倍数。<br> 【输入格式】<br> 输入的第一行包含一个整数 n。<br> 第二行包含三个整数 a, b, c，相邻两个数之间用一个空格分隔。<br> 【输出格式】<br> 输出一行包含一个整数，表示答案。<br> 【样例输入】<br> 30<br> 2 3 6<br> 【样例输出】<br> 10<br> 【样例说明】 以下这些数满足要求：1, 5, 7, 11, 13, 17, 19, 23, 25, 29。<br> 【评测用例规模与约定】<br> 对于 40% 的评测用例，1 &lt;= n &lt;= 10000。<br> 对于 80% 的评测用例，1 &lt;= n &lt;= 100000。<br> 对于所有评测用例，1 &lt;= n &lt;= 1000000，1 &lt;= a &lt;= n，1 &lt;= b &lt;= n，1 &lt;= c &lt;= n。</p><h3 id="思路" tabindex="-1"><a class="header-anchor" href="#思路" aria-hidden="true">#</a> 思路</h3><p>反倍数就是不能同时被a , b, c整除的数，那么我们就从 1 循环到 n ，如果出现一个不能同时被a, b, c整除的数，那么就计数加一，因为我们最后要求的是从 1 到 n 中反倍数的个数。也可以逆向思考，如果一个数能被a, b或者c整除，那么这个数就一定不是反倍数，所以我们统计出能被a, b或者c整除的数，然后总的 n 个数减去统计出的数字，就是我们需要的答案。</p><h3 id="源代码" tabindex="-1"><a class="header-anchor" href="#源代码" aria-hidden="true">#</a> 源代码</h3><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint n, a, b, c;    // 定义变量 \nint ans = 0;     \n\nint main() {\n\tcin &gt;&gt; n;     //输入一个整数 n 代表从 1 到 n \n\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; c;  //输入三个整数 \n\tfor(int i = 1; i &lt;= n; i++) {  // 从 1 循环 ，一直循环到 n  \n\t\tif(i % a != 0 &amp;&amp; i % b != 0 &amp;&amp; i % c != 0) {  // 如果一个数不能被 a 或者 b 或者 c 整除的话，那么就是反倍数   % 取余数 根据余数是否为 0 来判断是否能整除 \n\t\t\tans++;  // 有的话就加一 \n\t\t}\n\t/*\n\t\tif(i % a == 0 || i % b == 0 || i % c == 0) {  // 如果一个数能被 a 或者 b 或者 c 整除的话,那么就不是反倍数   % 取余数 根据余数是否为 0 来判断是否能整除 \n\t\t\tans++;  // 有的话就加一 \n\t\t}\n\t*/\n\t}\n\tcout &lt;&lt; ans;\n  //cout &lt;&lt; n-ans;  // 输出反倍数的个数 \n\treturn 0;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>#include&lt;stdio.h&gt;\n\nint main(){\n\tint n,a,b,c;\n\tint ans = 0;\n\t\n\tscanf(&quot;%d&quot;,&amp;n);\n\tscanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c);\n\t\n\tfor(int i = 1;i&lt;=n;i++){\n\t\tif(i % a != 0 &amp;&amp; i % b !=0 &amp;&amp; i % c != 0){\n\t\t\tans++;\n\t\t}\n\t} \n\tprintf(&quot;%d&quot;,ans);\n\t\n\treturn 0;\n} \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h2 id="_6-凯撒加密" tabindex="-1"><a class="header-anchor" href="#_6-凯撒加密" aria-hidden="true">#</a> 6. 凯撒加密</h2><h3 id="问题描述-4" tabindex="-1"><a class="header-anchor" href="#问题描述-4" aria-hidden="true">#</a> 问题描述</h3><p>【问题描述】<br>给定一个单词，请使用凯撒密码将这个单词加密。<br>凯撒密码是一种替换加密的技术，单词中的所有字母都在字母表上向后偏移3位后被替换成密文。即a变为d，b变为e，...，w变为z，x变为a，y变为b，z变为c。<br>例如，lanqiao会变成odqtldr。<br>【输入格式】<br>输入一行，包含一个单词，单词中只包含小写英文字母。<br>【输出格式】<br>输出一行，表示加密后的密文。<br>【样例输入】<br>lanqiao<br>【样例输出】<br>odqtldr<br>【评测用例规模与约定】<br>对于所有评测用例，单词中的字母个数不超过100。<br><br><br></p><h3 id="思路-1" tabindex="-1"><a class="header-anchor" href="#思路-1" aria-hidden="true">#</a> 思路</h3><p>这个题目主要是考查ASCII码值，加密时，每个字母的ASCII的值加 3 ，就能得到加密后的字母。但是最后的三个字母x , y, z加密和应该变成a, b, c所以需要对26取余数。a 的ASCII值是97（十进制），所以应该每个字母的 ASCII 的值应该减去 97 再加 3 然后对 26 取余数后再加上97。</p><h3 id="源代码-1" tabindex="-1"><a class="header-anchor" href="#源代码-1" aria-hidden="true">#</a> 源代码</h3><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstring str = &quot;&quot;;     //定义一个字符串 \n\nchar solve(char ch){   \n    return char(97 + ((int(ch) - 97 + 3) % 26));  //字母加密过程 \n}\nint main() {\n    getline(cin,str);\n    for(int i = 0; i &lt; str.length(); i++){     //如果用C语言就会不方便求解字符串的实际长度，不利于计算\n        str[i] = solve(str[i]);\n    }\n    cout&lt;&lt;str;\n    return 0;\n}\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h2 id="_7-螺旋" tabindex="-1"><a class="header-anchor" href="#_7-螺旋" aria-hidden="true">#</a> 7. 螺旋</h2><h3 id="问题描述-5" tabindex="-1"><a class="header-anchor" href="#问题描述-5" aria-hidden="true">#</a> 问题描述</h3><p>【问题描述】<br>对于一个 n 行 m 列的表格，我们可以使用螺旋的方式给表格依次填上正整数，我们称填好的表格为一个螺旋矩阵。<br>例如，一个 4 行 5 列的螺旋矩阵如下：<br>1 2 3 4 5<br>14 15 16 17 6<br>13 20 19 18 7<br>12 11 10 9 8<br>【输入格式】<br>输入的第一行包含两个整数 n, m，分别表示螺旋矩阵的行数和列数。<br>第二行包含两个整数 r, c，表示要求的行号和列号。<br>【输出格式】<br>输出一个整数，表示螺旋矩阵中第 r 行第 c 列的元素的值。<br>【样例输入】<br>4 5<br>2 2<br>【样例输出】<br>15<br>【评测用例规模与约定】<br>对于 30% 的评测用例，2 &lt;= n, m &lt;= 20。<br>对于 70% 的评测用例，2 &lt;= n, m &lt;= 100。<br>对于所有评测用例，2 &lt;= n, m &lt;= 1000，1 &lt;= r &lt;= n，1 &lt;= c &lt;= m。<br><br><br></p><h3 id="思路-2" tabindex="-1"><a class="header-anchor" href="#思路-2" aria-hidden="true">#</a> 思路</h3><p>螺旋问题最后需要我们输出的是某一个特定位置的元素的值，在一个矩阵里面，就需要我们使用二维数组，进行二维数组的填充。观察螺旋矩阵，是依次向右、向下、向左、向上填充元素的。</p><h3 id="源代码-2" tabindex="-1"><a class="header-anchor" href="#源代码-2" aria-hidden="true">#</a> 源代码</h3><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint a[1002][1002];\nint n, m, r, c, cnt = 0;\n\nint main() {\n\tcin &gt;&gt; n &gt;&gt; m; // 矩阵的行和列 \n\tcin &gt;&gt; r &gt;&gt; c; // 想要求的行号和列号 \n\tmemset(a, 0, sizeof(a)); //给数组 a 赋上初始值 0 \n\tint x = 0, y = 0;\n\ta[x][y] = ++cnt;\n\twhile(cnt &lt; n * m) {\n\t\twhile(y + 1 &lt; m &amp;&amp; !a[x][y + 1]) {  //右 \n\t\t\ta[x][++y] = ++cnt;\n\t\t}\n\t\twhile(x + 1 &lt; n &amp;&amp; !a[x + 1][y]) {  //下 \n\t\t\ta[++x][y] = ++cnt;\n\t\t}\n\t\twhile(y - 1 &gt;= 0 &amp;&amp; !a[x][y - 1]) { //左 \n\t\t\ta[x][--y] = ++cnt;\n\t\t}\n\t\twhile(x - 1 &gt;= 0 &amp;&amp; !a[x - 1][y]) { //上 \n\t\t\ta[--x][y] = ++cnt;\n\t\t}\n\t}\n/*\tfor(int i = 0; i &lt; n; i++) {\n\t\tfor(int j = 0; j &lt; m; j++) {\n\t\t\tcout &lt;&lt; a[i][j] &lt;&lt;&#39; &#39;;\n\t\t}\n\t\tcout &lt;&lt; endl;\n\t}\n*/\n\tcout&lt;&lt;a[r - 1][c - 1];  //输出特定位置的元素的值\n\treturn 0;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div>',50),r={},l=(0,e(3744).Z)(r,[["render",function(n,a){return s}]])}}]);