"use strict";(self.webpackChunkafternoon_grocery_store=self.webpackChunkafternoon_grocery_store||[]).push([[9189],{5608:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e={key:"v-41e3d9a4",path:"/blogs/LanQiao/20200304The11thSchoolSimulationLanQiaoCup.html",title:"第十一届蓝桥杯校内模拟赛",lang:"zh-CN",frontmatter:{title:"第十一届蓝桥杯校内模拟赛",date:"2021-03-04T00:00:00.000Z",tags:["蓝桥杯"],categories:["竞赛真题"]},excerpt:"",headers:[{level:2,title:"题目",slug:"题目",children:[]},{level:2,title:"1. 15.125GB",slug:"_1-15-125gb",children:[{level:3,title:"问题描述",slug:"问题描述",children:[]},{level:3,title:"题解",slug:"题解",children:[]}]},{level:2,title:"2. 约数个数",slug:"_2-约数个数",children:[{level:3,title:"题解",slug:"题解-1",children:[]}]},{level:2,title:"3. 叶结点数",slug:"_3-叶结点数",children:[{level:3,title:"问题描述",slug:"问题描述-1",children:[]},{level:3,title:"题解",slug:"题解-2",children:[]}]},{level:2,title:"4. 数字9",slug:"_4-数字9",children:[{level:3,title:"问题描述",slug:"问题描述-2",children:[]},{level:3,title:"题解",slug:"题解-3",children:[]}]},{level:2,title:"5. 数位递增的数",slug:"_5-数位递增的数",children:[{level:3,title:"问题描述",slug:"问题描述-3",children:[]},{level:3,title:"思路",slug:"思路",children:[]},{level:3,title:"源代码",slug:"源代码",children:[]}]},{level:2,title:"6. 递增三元组",slug:"_6-递增三元组",children:[{level:3,title:"问题描述",slug:"问题描述-4",children:[]},{level:3,title:"思路",slug:"思路-1",children:[]},{level:3,title:"源代码",slug:"源代码-1",children:[]}]},{level:2,title:"7. 音节判断",slug:"_7-音节判断",children:[{level:3,title:"问题描述",slug:"问题描述-5",children:[]},{level:3,title:"思路",slug:"思路-2",children:[]},{level:3,title:"源代码",slug:"源代码-2",children:[]}]}],git:{createdTime:1642079704e3,updatedTime:1642079704e3,contributors:[{name:"shinuyeim",email:"shinuyemail@gmail.com",commits:1}]}}},5138:(n,s,a)=>{a.r(s),a.d(s,{default:()=>l});const e=(0,a(6252).uE)('<h2 id="题目" tabindex="-1"><a class="header-anchor" href="#题目" aria-hidden="true">#</a> 题目</h2><h2 id="_1-15-125gb" tabindex="-1"><a class="header-anchor" href="#_1-15-125gb" aria-hidden="true">#</a> 1. 15.125GB</h2><h3 id="问题描述" tabindex="-1"><a class="header-anchor" href="#问题描述" aria-hidden="true">#</a> 问题描述</h3><p>【问题描述】<br>在计算机存储中，15.125GB是多少MB？<br>【答案提交】<br>这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。<br><br><br></p><h3 id="题解" tabindex="-1"><a class="header-anchor" href="#题解" aria-hidden="true">#</a> 题解</h3><p>此题和蓝桥杯第11次大赛的第一天相似，15.125GB = 15.125 * 1024 MB = 15,488MB</p><table><thead><tr><th style="text-align:center;"></th><th style="text-align:center;"></th><th style="text-align:center;"></th></tr></thead><tbody><tr><td style="text-align:center;">1B</td><td style="text-align:center;">=</td><td style="text-align:center;">8bit</td></tr><tr><td style="text-align:center;">1KB</td><td style="text-align:center;">=</td><td style="text-align:center;">1024B</td></tr><tr><td style="text-align:center;">1MB</td><td style="text-align:center;">=</td><td style="text-align:center;">1024KB</td></tr><tr><td style="text-align:center;">1GB</td><td style="text-align:center;">=</td><td style="text-align:center;">1024MB</td></tr><tr><td style="text-align:center;">1TB</td><td style="text-align:center;">=</td><td style="text-align:center;">1024GB</td></tr></tbody></table><h4 id="答案" tabindex="-1"><a class="header-anchor" href="#答案" aria-hidden="true">#</a> 答案</h4><p>15488</p><h2 id="_2-约数个数" tabindex="-1"><a class="header-anchor" href="#_2-约数个数" aria-hidden="true">#</a> 2. 约数个数</h2><p>【问题描述】<br>1200000有多少个约数（只计算正约数）。<br>【答案提交】<br>这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。<br><br><br></p><h3 id="题解-1" tabindex="-1"><a class="header-anchor" href="#题解-1" aria-hidden="true">#</a> 题解</h3><p>要求约数的个数，可以从一循环到1200000，统计出能够被1200000整除的数字的个数。</p><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main(){\n    int cnt;\n\t\n\tfor(int i = 1;i&lt;=1200000;i++){\n\t\tif(1200000 % i == 0)\n\t\t\tcnt++;\n\t} \n\tcout &lt;&lt; cnt &lt;&lt; endl;\n\t\n\treturn 0;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h4 id="答案-1" tabindex="-1"><a class="header-anchor" href="#答案-1" aria-hidden="true">#</a> 答案</h4><p>96</p><h2 id="_3-叶结点数" tabindex="-1"><a class="header-anchor" href="#_3-叶结点数" aria-hidden="true">#</a> 3. 叶结点数</h2><h3 id="问题描述-1" tabindex="-1"><a class="header-anchor" href="#问题描述-1" aria-hidden="true">#</a> 问题描述</h3><p>【问题描述】<br>一棵包含有2019个结点的二叉树，最多包含多少个叶结点？<br>【答案提交】<br>这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。<br><br><br></p><h3 id="题解-2" tabindex="-1"><a class="header-anchor" href="#题解-2" aria-hidden="true">#</a> 题解</h3><p>二叉树的一个性质是第 i 层上最多有 2^i-1 个结点(i&gt;=1)，这样我们可以得出二叉树每一层的结点个数，叶结点是没有左右子树的，所以我们首先需要知道第2019个结点在二叉树上的位置，才能得到最后的答案。</p><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>#include &lt;iostream&gt;\n#include &lt;math.h&gt;\n//#include&lt;bits/stdc++.h&gt; \nusing namespace std;\n\nint main(){\n\tdouble n;\n\tint i;\n\tdouble cnt = 0;\n\tcin &gt;&gt; n;\n\tfor(i = 1; cnt &lt;= n; i++){\n\t\tcnt = pow(2.0,i-1) + cnt;\n\t}\n\tcout &lt;&lt; i-1;\n\treturn 0;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>这段代码可以求出第 N 个结点在二叉树的第几层，i 代表层数，可以求出第2019个结点在二叉树的第十一层，第一层到第十层共计有 2^0 + 2^1 + 2^2 + ... + 2^9 = 1023 个结点，第一层到第十一层共有 2047 个结点。确定了第 2019 个结点在第十一层，那么第 2019 个结点在第十一层的哪里呢? 前十层占据了1023 个结点，那么就可以知道第 2019 个结点在第十一层的第 2019 - 1023 个位置处。也就是第 996 个结点，第十一层的 996 个结点占据了第十层的 996 / 2 个结点，也就是第十层有 498 个父结点，那么第十层一共有 512 个结点，其中有 498 个有叶子结点，那么还剩 512 - 498(14) 个叶子节点，总共的叶子结点就是第十一层的 996 个加上第十层的 14 个，一共 1010 个叶子节点。所以答案为1010。</p><h4 id="答案-2" tabindex="-1"><a class="header-anchor" href="#答案-2" aria-hidden="true">#</a> 答案</h4><p>1010</p><h2 id="_4-数字9" tabindex="-1"><a class="header-anchor" href="#_4-数字9" aria-hidden="true">#</a> 4. 数字9</h2><h3 id="问题描述-2" tabindex="-1"><a class="header-anchor" href="#问题描述-2" aria-hidden="true">#</a> 问题描述</h3><p>【问题描述】<br>在1至2019中，有多少个数的数位中包含数字9？<br>注意，有的数中的数位中包含多个9，这个数只算一次。例如，1999这个数包含数字9，在计算只是算一个数。<br>【答案提交】<br>这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。<br><br><br><br></p><h3 id="题解-3" tabindex="-1"><a class="header-anchor" href="#题解-3" aria-hidden="true">#</a> 题解</h3><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main(){\n\tint cnt = 0;\n\tint n = 2019;\n\twhile(n--){\n\t\tstring s = to_string(n); //to_string 编译时需要c++11支持 \n\t\tif(s.find(&#39;9&#39;) != string::npos)\n\t\t\tcnt++;\n\t}\n\tcout &lt;&lt; cnt;\n\t\n\treturn 0;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h4 id="答案-3" tabindex="-1"><a class="header-anchor" href="#答案-3" aria-hidden="true">#</a> 答案</h4><p>543</p><h2 id="_5-数位递增的数" tabindex="-1"><a class="header-anchor" href="#_5-数位递增的数" aria-hidden="true">#</a> 5. 数位递增的数</h2><h3 id="问题描述-3" tabindex="-1"><a class="header-anchor" href="#问题描述-3" aria-hidden="true">#</a> 问题描述</h3><p>【问题描述】<br>一个正整数如果任何一个数位不大于右边相邻的数位，则称为一个数位递增的数，例如1135是一个数位递增的数，而1024不是一个数位递增的数。<br>给定正整数 n，请问在整数 1 至 n 中有多少个数位递增的数？<br>【输入格式】<br>输入的第一行包含一个整数 n。<br>【输出格式】<br>输出一行包含一个整数，表示答案。<br>【样例输入】<br>30<br>【样例输出】<br>26<br>【评测用例规模与约定】<br>对于 40% 的评测用例，1 &lt;= n &lt;= 1000。<br>对于 80% 的评测用例，1 &lt;= n &lt;= 100000。<br>对于所有评测用例，1 &lt;= n &lt;= 1000000。<br><br><br></p><h3 id="思路" tabindex="-1"><a class="header-anchor" href="#思路" aria-hidden="true">#</a> 思路</h3><p>借助于转化字符串方便的原因，我们把数字转化为字符串，然后两两相邻的数字比较，若出现前面的数字小于后面的就可以确定这个数字不是递增的数，统计数量即可。</p><h3 id="源代码" tabindex="-1"><a class="header-anchor" href="#源代码" aria-hidden="true">#</a> 源代码</h3><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main(){\n\tint n, cnt = 0;\n\t\n\tcin &gt;&gt; n;\n\t\n\tfor(int i = 1;i &lt;= n;i++){\n\t\tstring s = to_string(i);\n\t\tbool flag = true;\n\t\tfor(int j = 0; j &lt; s.length() -1;j++){\n\t\t\tif(s[j] &gt; s[j + 1])\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t}\n\t\tif(flag)\n\t\t\tcnt++;\n\t}\n\t\n\tcout &lt;&lt; cnt;\n\treturn 0;\n}\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h2 id="_6-递增三元组" tabindex="-1"><a class="header-anchor" href="#_6-递增三元组" aria-hidden="true">#</a> 6. 递增三元组</h2><h3 id="问题描述-4" tabindex="-1"><a class="header-anchor" href="#问题描述-4" aria-hidden="true">#</a> 问题描述</h3><p>【问题描述】<br>在数列 a[1], a[2], ..., a[n] 中，如果对于下标 i, j, k 满足 0&lt;i&lt;j&lt;k&lt;n+1 且 a[i]&lt;a[j]&lt;a[k]，则称 a[i], a[j], a[k] 为一组递增三元组，a[j]为递增三元组的中心。<br>给定一个数列，请问数列中有多少个元素可能是递增三元组的中心。<br>【输入格式】<br>输入的第一行包含一个整数 n。<br>第二行包含 n 个整数 a[1], a[2], ..., a[n]，相邻的整数间用空格分隔，表示给定的数列。<br>【输出格式】<br>输出一行包含一个整数，表示答案。<br>【样例输入】<br>5<br>1 2 5 3 5<br>【样例输出】<br>2<br>【样例说明】<br>a[2] 和 a[4] 可能是三元组的中心。<br>【评测用例规模与约定】<br>对于 50% 的评测用例，2 &lt;= n &lt;= 100，0 &lt;= 数列中的数 &lt;= 1000。<br>对于所有评测用例，2 &lt;= n &lt;= 1000，0 &lt;= 数列中的数 &lt;= 10000。<br><br></p><h3 id="思路-1" tabindex="-1"><a class="header-anchor" href="#思路-1" aria-hidden="true">#</a> 思路</h3><p>本题有规定评测用例规模，对于 50% 的用例 2 &lt;= n &lt;= 100，0 &lt;= 数列中的数 &lt;= 1000。则证明如果用暴力法，最多得到一半的分数。如果实在没有思路的话可以用暴力法。暴力法需要三重循环，如果不用暴力法的话，就需要一些技巧。</p><h3 id="源代码-1" tabindex="-1"><a class="header-anchor" href="#源代码-1" aria-hidden="true">#</a> 源代码</h3><hr><p><strong>暴力法(三重循环)</strong></p><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint a[1005];\nint b[1005];\nint main()\n{\n\tint n, ans = 0;//计数\n\tint ind = 1;//用于存放符合条件的三元组中心的下标\n\tcin &gt;&gt; n;\n\tfor (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];\n\n\tfor (int i = 1; i &lt;= n - 2; i++)\n\t{\n\t\tfor (int j = i + 1; j &lt;= n - 1; j++)\n\t\t{\n\t\t\tfor (int k = j + 1; k &lt;= n; k++)\n\t\t\t{\n\t\t\t\t//如果满足题意，则将三元组中心的下标存入数组中\n\t\t\t\tif (a[i] &lt; a[j] &amp;&amp; a[j] &lt; a[k])\n\t\t\t\t{\n\t\t\t\t\tb[ind++] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//对存放入数组中的不同下标进行计数\n\tsort(b, b + ind);\n\tfor (int i = 1; i &lt; ind; i++)\n\t{\n\t\tif (b[i] != b[i - 1]) ans++;\n\t}\n\tcout &lt;&lt; ans;\n\treturn 0;\n}\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><hr><p><strong>双重循环</strong></p><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>#include &lt;iostream&gt;\nusing namespace std; \nconst int N = 1005;\nint n, p[N], ans;\nbool ok(int x) {\n\tbool ok = false;    //初始化 ok 的值\n\tfor (int i = x - 1; i &gt;= 1; i--) {\n\t\tif (p[i] &lt; p[x]) {       //判断 x 前面是否存在小于p[x]的的元素 \n\t\t\tok = true; break;    //若存在，ok=true,退出循环，因为只要找到一个是小于 x 的就行，不用一直循环到p数组的第一个元素 \n\t\t}\n\t}\n\tif (!ok) return false;       //判断 x 前面是否有比p[x]小的元素，如果没有则直接返回false,证明没有递增三元组 \n\tfor (int i = x + 1; i &lt;= n; i++) {  \n\t\tif (p[x] &lt; p[i]) return true;  //判断 x 后面是否有大于p[x]的元素 \n\t}\n\treturn false;\n}\nint main() {\n \tcin &gt;&gt; n;\n \tfor (int i = 1; i &lt;= n; i++) {\n\t\tcin &gt;&gt; p[i];        //数据的输入，下标从 1 开始 \n\t}\n\tfor (int i = 1; i &lt;= n; i++) {\n\t\tif (ok(i)) ans++;\n\t}\n \tcout &lt;&lt; ans;    \n\treturn 0;\n}\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><h2 id="_7-音节判断" tabindex="-1"><a class="header-anchor" href="#_7-音节判断" aria-hidden="true">#</a> 7. 音节判断</h2><h3 id="问题描述-5" tabindex="-1"><a class="header-anchor" href="#问题描述-5" aria-hidden="true">#</a> 问题描述</h3><p>【问题描述】<br>小明对类似于 hello 这种单词非常感兴趣，这种单词可以正好分为四段，第一段由一个或多个辅音字母组成，第二段由一个或多个元音字母组成，第三段由一个或多个辅音字母组成，第四段由一个或多个元音字母组成。<br>给定一个单词，请判断这个单词是否也是这种单词，如果是请输出yes，否则请输出no。<br>元音字母包括 a, e, i, o, u，共五个，其他均为辅音字母。<br>【输入格式】<br>输入一行，包含一个单词，单词中只包含小写英文字母。<br>【输出格式】<br>输出答案，或者为yes，或者为no。<br>【样例输入】<br>lanqiao<br>【样例输出】<br>yes<br>【样例输入】<br>world<br>【样例输出】<br>no<br>【评测用例规模与约定】<br>对于所有评测用例，单词中的字母个数不超过100。<br><br></p><h3 id="思路-2" tabindex="-1"><a class="header-anchor" href="#思路-2" aria-hidden="true">#</a> 思路</h3><p>结构为辅音元音辅音元音的单词输出 yes ,否则输出 no ,则可以一个一个的判断。</p><h3 id="源代码-2" tabindex="-1"><a class="header-anchor" href="#源代码-2" aria-hidden="true">#</a> 源代码</h3><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nbool ok(char c){\n\tif(c == &#39;a&#39; || c == &#39;e&#39; || c == &#39;i&#39; || c == &#39;o&#39; || c == &#39;u&#39;)\n\t\treturn true;\n\treturn false;\n}\n\nint main(){\n\tstring str;\n\tint step = 0;\n\t\n\tcin &gt;&gt; str;\n\t\n\tfor(int i = 0;i &lt; str.size();i++){\n\t\tif(step == 0){\n\t\t\tif(!ok(str[i])) step = 1; //判断第一段是否为辅音,如果是辅音则step = 1，是元音的话则继续判断下一个字符 \n\t\t}\n\t\tif(step == 1){\n\t\t\tif(ok(str[i])) step = 2;  //判断第二段是否为元音,如果是元音就step = 2, 是辅音的话则判断下一个字符 \n\t\t}\n\t\tif(step == 2){\n\t\t\tif(!ok(str[i])) step = 3; //判断第三段是否为辅音,如果是辅音则step = 1，是元音的话则继续判断下一个字符 \n\t\t}\n\t\tif(step = 3){\n\t\t\tif(ok(str[i])) step = 4;  //判断第四段是否为辅音,如果是辅音则step = 1，是元音的话则继续判断下一个字符 \n\t\t}\t\n\t}\n\tif(step == 4)\n\t\tcout &lt;&lt; &quot;yes&quot; &lt;&lt;endl;\n\telse\n\t\tcout &lt;&lt; &quot;no&quot; &lt;&lt;endl;\n\t\n\treturn 0;\n}\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div>',58),r={},l=(0,a(3744).Z)(r,[["render",function(n,s){return e}]])}}]);