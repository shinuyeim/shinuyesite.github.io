"use strict";(self.webpackChunkafternoon_grocery_store=self.webpackChunkafternoon_grocery_store||[]).push([[237],{4313:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e={key:"v-6c599e49",path:"/blogs/LeetCode/2020/12-16-744LookLargerThanTheTargetLetterTheSmallestLetter.html",title:"寻找比目标字母大的最小字母",lang:"zh-CN",frontmatter:{title:"寻找比目标字母大的最小字母",date:"2020-12-16T00:00:00.000Z",tags:["简单","力扣","二分搜索"],categories:["算法笔记"]},excerpt:"",headers:[{level:2,title:"题目描述",slug:"题目描述",children:[]},{level:2,title:"示例",slug:"示例",children:[]},{level:2,title:"算法设计",slug:"算法设计",children:[]},{level:2,title:"代码",slug:"代码",children:[]},{level:2,title:"复杂度分析",slug:"复杂度分析",children:[]}],git:{createdTime:1642079704e3,updatedTime:1642079704e3,contributors:[{name:"shinuyeim",email:"shinuyemail@gmail.com",commits:1}]}}},5093:(n,s,a)=>{a.r(s),a.d(s,{default:()=>k});var e=a(6252);const t=(0,e._)("h2",{id:"题目描述",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#题目描述","aria-hidden":"true"},"#"),(0,e.Uk)(" 题目描述")],-1),l=(0,e._)("p",null,"给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。",-1),r=(0,e._)("p",null,"在比较时，字母是依序循环出现的。举个例子：",-1),p=(0,e._)("p",null,"如果目标字母 target = 'z' 并且字符列表为 letters = ['a', 'b']，则答案返回 'a'",-1),o=(0,e._)("h2",{id:"示例",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#示例","aria-hidden":"true"},"#"),(0,e.Uk)(" 示例")],-1),c=(0,e._)("div",{class:"custom-container tip"},[(0,e._)("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[(0,e._)("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[(0,e._)("circle",{cx:"12",cy:"12",r:"9"}),(0,e._)("path",{d:"M12 8h.01"}),(0,e._)("path",{d:"M11 12h1v4h1"})])]),(0,e._)("p",{class:"custom-container-title"},"TIP"),(0,e._)("p",null,[(0,e.Uk)("输入:"),(0,e._)("br"),(0,e.Uk)(' letters = ["c", "f", "j"]'),(0,e._)("br"),(0,e.Uk)(' target = "a"'),(0,e._)("br"),(0,e.Uk)(' 输出: "c')]),(0,e._)("p",null,[(0,e.Uk)("输入:"),(0,e._)("br"),(0,e.Uk)(' letters = ["c", "f", "j"]'),(0,e._)("br"),(0,e.Uk)(' target = "c"'),(0,e._)("br"),(0,e.Uk)(' 输出: "f"')]),(0,e._)("p",null,[(0,e.Uk)("输入:"),(0,e._)("br"),(0,e.Uk)(' letters = ["c", "f", "j"]'),(0,e._)("br"),(0,e.Uk)(' target = "g"'),(0,e._)("br"),(0,e.Uk)(' 输出: "j"')]),(0,e._)("p",null,[(0,e.Uk)("输入:"),(0,e._)("br"),(0,e.Uk)(' letters = ["c", "f", "j"]'),(0,e._)("br"),(0,e.Uk)(' target = "j"'),(0,e._)("br"),(0,e.Uk)(' 输出: "c"')]),(0,e._)("p",null,[(0,e.Uk)("输入:"),(0,e._)("br"),(0,e.Uk)(' letters = ["c", "f", "j"]'),(0,e._)("br"),(0,e.Uk)(' target = "k"'),(0,e._)("br"),(0,e.Uk)(' 输出: "c"')])],-1),i=(0,e.uE)('<h2 id="算法设计" tabindex="-1"><a class="header-anchor" href="#算法设计" aria-hidden="true">#</a> 算法设计</h2><p>这是一个有序数组，并且数组中也没有重复的元素，我们运用二分法查找时。二分查找分几轮进行，在每一轮中我们保持循环始终在区间 [lo，hi]。让 mi = (lo + hi) / 2。若 letters[mi] &lt;= target，则我们修改查找区间为 [mi + 1, hi]，否则，我们修改为 [lo, mi]。<br> 最后，如果插入位置是最后一个位置 letters.length，则返回 letters[0]。这就是模运算的运用。</p><h2 id="代码" tabindex="-1"><a class="header-anchor" href="#代码" aria-hidden="true">#</a> 代码</h2><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">char</span> <span class="token function">nextGreatestLetter</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> letters<span class="token punctuation">,</span> <span class="token keyword">int</span> lettersSize<span class="token punctuation">,</span> <span class="token keyword">char</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">int</span> lo <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> hi <span class="token operator">=</span> lettersSize<span class="token punctuation">;</span>\n    <span class="token keyword">while</span> <span class="token punctuation">(</span>lo <span class="token operator">&lt;</span> hi<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">int</span> mi <span class="token operator">=</span> lo <span class="token operator">+</span> <span class="token punctuation">(</span>hi <span class="token operator">-</span> lo<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>letters<span class="token punctuation">[</span>mi<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target<span class="token punctuation">)</span> lo <span class="token operator">=</span> mi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>\n        <span class="token keyword">else</span> hi <span class="token operator">=</span> mi<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> letters<span class="token punctuation">[</span>lo <span class="token operator">%</span> lettersSize<span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="复杂度分析" tabindex="-1"><a class="header-anchor" href="#复杂度分析" aria-hidden="true">#</a> 复杂度分析</h2><p>时间复杂度：O(\\log N)O(logN)。NN 指的是 letters 的长度，我们只查看数组中的 \\log nlogn 个元素。<br> 空间复杂度：O(1)O(1)。只使用了指针。</p>',6),u={},k=(0,a(3744).Z)(u,[["render",function(n,s){return(0,e.wg)(),(0,e.iD)(e.HY,null,[t,l,r,p,o,c,i],64)}]])}}]);