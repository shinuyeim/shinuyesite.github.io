"use strict";(self.webpackChunkafternoon_grocery_store=self.webpackChunkafternoon_grocery_store||[]).push([[5923],{5624:(n,s,a)=>{a.r(s),a.d(s,{data:()=>p});const p={key:"v-ee6af1b0",path:"/blogs/LeetCode/2021/2021-05-14-349TheIntersectionOfTheTwoArrays.html",title:"两个数组的交集",lang:"zh-CN",frontmatter:{title:"两个数组的交集",date:"2021-05-14T00:00:00.000Z",tags:["简单","力扣","排序"],categories:["算法笔记"]},excerpt:"",headers:[{level:2,title:"题目描述",slug:"题目描述",children:[]},{level:2,title:"示例",slug:"示例",children:[]},{level:2,title:"算法设计",slug:"算法设计",children:[]},{level:2,title:"代码",slug:"代码",children:[]},{level:2,title:"复杂度分析",slug:"复杂度分析",children:[]},{level:2,title:"总结",slug:"总结",children:[]}],git:{createdTime:1642079704e3,updatedTime:1642079704e3,contributors:[{name:"shinuyeim",email:"shinuyemail@gmail.com",commits:1}]}}},1512:(n,s,a)=>{a.r(s),a.d(s,{default:()=>g});var p=a(6252);const t=(0,p._)("h2",{id:"题目描述",tabindex:"-1"},[(0,p._)("a",{class:"header-anchor",href:"#题目描述","aria-hidden":"true"},"#"),(0,p.Uk)(" 题目描述")],-1),e=(0,p._)("p",null,"给定两个数组，编写一个函数来计算它们的交集。",-1),o=(0,p._)("h2",{id:"示例",tabindex:"-1"},[(0,p._)("a",{class:"header-anchor",href:"#示例","aria-hidden":"true"},"#"),(0,p.Uk)(" 示例")],-1),c=(0,p._)("div",{class:"custom-container tip"},[(0,p._)("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[(0,p._)("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[(0,p._)("circle",{cx:"12",cy:"12",r:"9"}),(0,p._)("path",{d:"M12 8h.01"}),(0,p._)("path",{d:"M11 12h1v4h1"})])]),(0,p._)("p",{class:"custom-container-title"},"TIP"),(0,p._)("p",null,[(0,p.Uk)("输入：nums1 = [1,2,2,1], nums2 = [2,2]"),(0,p._)("br"),(0,p.Uk)(" 输出：[2]")]),(0,p._)("p",null,[(0,p.Uk)("输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]"),(0,p._)("br"),(0,p.Uk)(" 输出：[9,4]")])],-1),l=(0,p._)("p",null,"Tips:",-1),r=(0,p._)("ol",null,[(0,p._)("li",null,"输出结果中的每个元素一定是唯一的。"),(0,p._)("li",null,"我们可以不考虑输出结果的顺序。")],-1),u=(0,p._)("h2",{id:"算法设计",tabindex:"-1"},[(0,p._)("a",{class:"header-anchor",href:"#算法设计","aria-hidden":"true"},"#"),(0,p.Uk)(" 算法设计")],-1),i=(0,p._)("p",null,"需要求解两个数组的交集，也就是说找出两个数组中的相同元素，然后输出。",-1),k=(0,p._)("p",null,"首先想到的就是采用双指针，遍历循环两个数组，遇到相同的元素就添加到一个新的数组中。这是最暴力的方法，在不排序的前提下对两个数组求交集，要求最后的元素不重复，是不方便的，因为每一次当两个数组中出现同一个元素的时候，还要到返回数组中查找元素是否已经存在，并不有利于算法的设计。我们可以对其进行优化，就是先把原数组排序，排序后我们就在每一次要在返回数组增加元素时，只需判断待增加元素与返回数组最后一个元素是否相等，如果相等就不把元素加入到放回数组，这样能很方便的保证元素的唯一性。",-1),m=(0,p._)("p",null,"所以先对原数组进行排序，然后再遍历数组，逐个找到相同的元素。",-1),d=(0,p._)("strong",null,"qsort",-1),b=(0,p.Uk)("函数的具体使用方法参见"),h={href:"https://shinuyeim.github.io/shinuye-site/views/PCCNotes/20210521Qsort.html",target:"_blank",rel:"noopener noreferrer"},w=(0,p.Uk)("qsort函数使用方法简介"),y=(0,p.uE)('<h2 id="代码" tabindex="-1"><a class="header-anchor" href="#代码" aria-hidden="true">#</a> 代码</h2><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">int</span><span class="token operator">*</span> pa <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span>\n    <span class="token keyword">int</span><span class="token operator">*</span> pb <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>b<span class="token punctuation">;</span>\n    <span class="token keyword">int</span> num1 <span class="token operator">=</span> <span class="token operator">*</span>pa<span class="token punctuation">;</span>\n    <span class="token keyword">int</span> num2 <span class="token operator">=</span> <span class="token operator">*</span>pb<span class="token punctuation">;</span>\n    <span class="token keyword">return</span> num1 <span class="token operator">-</span> num2<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">intersection</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> nums1Size<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> nums2Size<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> returnSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">//先对两个数组进行排序，方便后续的查找</span>\n    <span class="token function">qsort</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> nums1Size<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">qsort</span><span class="token punctuation">(</span>nums2<span class="token punctuation">,</span> nums2Size<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token operator">*</span>returnSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">int</span><span class="token operator">*</span> intersection <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>nums1Size <span class="token operator">+</span> nums2Size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> nums1Size <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> nums2Size<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// 总结1</span>\n        <span class="token keyword">int</span> num1 <span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> num2 <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 总结2</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>num1 <span class="token operator">==</span> num2<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 保证加入元素的唯一性</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">*</span>returnSize<span class="token punctuation">)</span> <span class="token operator">||</span> num1 <span class="token operator">!=</span> intersection<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">*</span>returnSize<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                intersection<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">*</span>returnSize<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> num1<span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n            i<span class="token operator">++</span><span class="token punctuation">;</span>\n            j<span class="token operator">++</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>num1 <span class="token operator">&lt;</span> num2<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            i<span class="token operator">++</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n            j<span class="token operator">++</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> intersection<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><h2 id="复杂度分析" tabindex="-1"><a class="header-anchor" href="#复杂度分析" aria-hidden="true">#</a> 复杂度分析</h2><p>时间复杂度：O(nlogn)，其中 n 为 s 的长度。排序的时间复杂度为 O(nlogn)，比较两个字符串是否相等时间复杂度为 O(n)，因此总体时间复杂度为 O(n log n + n) = O(nlogn)。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ol><li>这里用while而不用for的原因是因为两个数组的长度不一定一样长，排完序后的数组，只要其中一个遍历完成，那么两个数组中的公共元素一定找完了，节省了遍历时间，尤其当两个数组长度相差很大的时候体现的尤为明显。</li><li>这里也可以不需要变量num1和num2，但是为了便于后面的书写，增加上两个变量是值得的。</li></ol>',6),_={},g=(0,a(3744).Z)(_,[["render",function(n,s){const a=(0,p.up)("OutboundLink");return(0,p.wg)(),(0,p.iD)(p.HY,null,[t,e,o,c,l,r,u,i,k,m,(0,p._)("p",null,[d,b,(0,p._)("a",h,[w,(0,p.Wm)(a)])]),y],64)}]])}}]);