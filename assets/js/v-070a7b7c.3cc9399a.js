"use strict";(self.webpackChunkafternoon_grocery_store=self.webpackChunkafternoon_grocery_store||[]).push([[50],{4223:(e,n,i)=>{i.r(n),i.d(n,{data:()=>l});const l={key:"v-070a7b7c",path:"/blogs/LeetCode/2020/10-20-02154.html",title:"寻找旋转排序数组中的最小值 II",lang:"zh-CN",frontmatter:{title:"寻找旋转排序数组中的最小值 II",date:"2020-10-20T00:00:00.000Z",tags:["简单","力扣"],categories:["算法笔记"]},excerpt:"",headers:[{level:2,title:"题目描述",slug:"题目描述",children:[{level:3,title:"示例1:",slug:"示例1",children:[]},{level:3,title:"示例2:",slug:"示例2",children:[]}]},{level:2,title:"题目分析",slug:"题目分析",children:[{level:3,title:"算法设计",slug:"算法设计",children:[]},{level:3,title:"代码",slug:"代码",children:[]},{level:3,title:"复杂度分析：",slug:"复杂度分析",children:[]}]}],git:{createdTime:1642079704e3,updatedTime:1642079704e3,contributors:[{name:"shinuyeim",email:"shinuyemail@gmail.com",commits:1}]}}},3499:(e,n,i)=>{i.r(n),i.d(n,{default:()=>k});var l=i(6252);const a=(0,l._)("h2",{id:"题目描述",tabindex:"-1"},[(0,l._)("a",{class:"header-anchor",href:"#题目描述","aria-hidden":"true"},"#"),(0,l.Uk)(" 题目描述")],-1),r=(0,l._)("p",null,[(0,l.Uk)("假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。"),(0,l._)("br"),(0,l.Uk)(" 请找出其中最小的元素。"),(0,l._)("br"),(0,l.Uk)(" 你可以假设数组中可能存在重复元素。")],-1),s=(0,l._)("h3",{id:"示例1",tabindex:"-1"},[(0,l._)("a",{class:"header-anchor",href:"#示例1","aria-hidden":"true"},"#"),(0,l.Uk)(" 示例1:")],-1),t=(0,l._)("div",{class:"custom-container tip"},[(0,l._)("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[(0,l._)("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[(0,l._)("circle",{cx:"12",cy:"12",r:"9"}),(0,l._)("path",{d:"M12 8h.01"}),(0,l._)("path",{d:"M11 12h1v4h1"})])]),(0,l._)("p",{class:"custom-container-title"},"TIP"),(0,l._)("p",null,"输入: [1,3,5] 输出: 1")],-1),h=(0,l._)("h3",{id:"示例2",tabindex:"-1"},[(0,l._)("a",{class:"header-anchor",href:"#示例2","aria-hidden":"true"},"#"),(0,l.Uk)(" 示例2:")],-1),o=(0,l._)("div",{class:"custom-container tip"},[(0,l._)("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[(0,l._)("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[(0,l._)("circle",{cx:"12",cy:"12",r:"9"}),(0,l._)("path",{d:"M12 8h.01"}),(0,l._)("path",{d:"M11 12h1v4h1"})])]),(0,l._)("p",{class:"custom-container-title"},"TIP"),(0,l._)("p",null,"输入: [2,2,2,0,1] 输出: 0")],-1),u=(0,l._)("h2",{id:"题目分析",tabindex:"-1"},[(0,l._)("a",{class:"header-anchor",href:"#题目分析","aria-hidden":"true"},"#"),(0,l.Uk)(" 题目分析")],-1),c=(0,l.Uk)("这是一个特殊处理的排序的数组，从某一个位置截取一部分到原数组的末尾。与"),d={href:"https://shinuyeim.github.io/shinuye-site/views/LeetCode/10-20-01153.html",target:"_blank",rel:"noopener noreferrer"},p=(0,l.Uk)("寻找旋转排序数组中的最小值"),m=(0,l.Uk)("不同的是，现在数组中会出现重复的元素，不过主要的方法还是二分搜索法的衍生。"),b=(0,l.uE)('<p>假设数组中最小的元素为x，则在旋转后的数组中，在x右侧的元素，它们的值一定都小于等于 x；而在x左侧的元素，它们的值一定都大于等于 x。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。</p><h3 id="算法设计" tabindex="-1"><a class="header-anchor" href="#算法设计" aria-hidden="true">#</a> 算法设计</h3><p>我们在查找过程中，设数组的左边界为left，右边界为right，中间值为mid。 因为原数组是升序排序的，我们先用a[mid]与a[right]比较，会有下面三种情况:</p><blockquote><ul><li>a[mid] &lt; a[right]，说明a[mid]是最小值右侧的元素，因此我们可以忽略掉a[mid]到a[right]的元素。比如有旋转数组a[7, 8, 1, 2, 3, 4, 5, 6]，此时a[mid]为2，而a[right]为6，最小值1在a[mid]前面，由此可以看出，当a[mid] &lt; a[right]时，最小值不会出现在a[mid]到a[right]区间。</li></ul></blockquote><blockquote><ul><li>a[mid] &gt; a[right]，说明a[mid]是最小值左侧的元素，因此我们可以忽略掉a[left]到a[mid]的元素，大家可以自己举例验证。</li></ul></blockquote><blockquote><ul><li>a[mid] == a[right]，由于重复元素的存在，我们并不能确定a[mid]究竟在最小值的什么位置，我们唯一可以知道的是，由于它们的值相同，所以无论a[high]是不是最小值，都有一个它的「替代品」a[pivot]，因此我们可以忽略二分查找区间的右端点。</li></ul></blockquote><h3 id="代码" tabindex="-1"><a class="header-anchor" href="#代码" aria-hidden="true">#</a> 代码</h3><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>int findMin(int* nums, int numsSize) {\n    int low = 0;\n    int high = numsSize - 1;\n    while (low &lt; high) {\n        int pivot = low + (high - low) / 2;\n        if (nums[pivot] &lt; nums[high]) {\n            high = pivot;\n        } else if (nums[pivot] &gt; nums[high]) {\n            low = pivot + 1;\n        } else {\n            high -= 1;\n        }\n    }\n    return nums[low];\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="复杂度分析" tabindex="-1"><a class="header-anchor" href="#复杂度分析" aria-hidden="true">#</a> 复杂度分析：</h3><blockquote><ul><li>时间复杂度：平均时间复杂度为O(logn)，其中n是数组a的长度。如果数组是随机生成的，那么数组中包含相同元素的概率很低，在二分查找的过程中，大部分情况都会忽略一半的区间。而在最坏情况下，如果数组中的元素完全相同，那么 while 循环就需要执行n次，每次忽略区间的右端点，时间复杂度为 O(n)。</li></ul></blockquote><blockquote><ul><li>空间复杂度：O(1)。</li></ul></blockquote>',11),g={},k=(0,i(3744).Z)(g,[["render",function(e,n){const i=(0,l.up)("OutboundLink");return(0,l.wg)(),(0,l.iD)(l.HY,null,[a,r,s,t,h,o,u,(0,l._)("p",null,[c,(0,l._)("a",d,[p,(0,l.Wm)(i)]),m]),b],64)}]])}}]);