"use strict";(self.webpackChunkafternoon_grocery_store=self.webpackChunkafternoon_grocery_store||[]).push([[4843],{21:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e={key:"v-2b37326c",path:"/blogs/LanQiao/20210309LanQiao.html",title:"蓝桥杯算法笔记",lang:"zh-CN",frontmatter:{title:"蓝桥杯算法笔记",date:"2021-03-09T00:00:00.000Z",tags:["简单","蓝桥杯"],categories:["算法笔记"]},excerpt:"",headers:[{level:2,title:"题目",slug:"题目",children:[]},{level:2,title:"1. 乌托邦树",slug:"_1-乌托邦树",children:[{level:3,title:"问题描述",slug:"问题描述",children:[]},{level:3,title:"题解",slug:"题解",children:[]},{level:3,title:"源代码",slug:"源代码",children:[]}]},{level:2,title:"2. 用杂志拼接信件",slug:"_2-用杂志拼接信件",children:[{level:3,title:"问题描述",slug:"问题描述-1",children:[]},{level:3,title:"思路",slug:"思路",children:[]},{level:3,title:"源代码",slug:"源代码-1",children:[]}]},{level:2,title:"3. 分发饼干",slug:"_3-分发饼干",children:[{level:3,title:"问题描述",slug:"问题描述-2",children:[]},{level:3,title:"思路",slug:"思路-1",children:[]},{level:3,title:"源代码",slug:"源代码-2",children:[]}]},{level:2,title:"4. 其他元素的乘积",slug:"_4-其他元素的乘积",children:[{level:3,title:"问题描述",slug:"问题描述-3",children:[]},{level:3,title:"思路",slug:"思路-2",children:[]},{level:3,title:"源代码",slug:"源代码-3",children:[]}]},{level:2,title:"5. 寻找 3 个数的最大乘积",slug:"_5-寻找-3-个数的最大乘积",children:[{level:3,title:"问题描述",slug:"问题描述-4",children:[]},{level:3,title:"思路",slug:"思路-3",children:[]},{level:3,title:"源代码",slug:"源代码-4",children:[]}]}],git:{createdTime:1642079704e3,updatedTime:1642079704e3,contributors:[{name:"shinuyeim",email:"shinuyemail@gmail.com",commits:1}]}}},3942:(n,s,a)=>{a.r(s),a.d(s,{default:()=>u});var e=a(6252);const l=(0,e.uE)('<h2 id="题目" tabindex="-1"><a class="header-anchor" href="#题目" aria-hidden="true">#</a> 题目</h2><h2 id="_1-乌托邦树" tabindex="-1"><a class="header-anchor" href="#_1-乌托邦树" aria-hidden="true">#</a> 1. 乌托邦树</h2><h3 id="问题描述" tabindex="-1"><a class="header-anchor" href="#问题描述" aria-hidden="true">#</a> 问题描述</h3><p>实现一个算法得到乌托邦树的高度。介绍如下：</p><p>乌托邦树每年经历 2 个生长周期。每年春天，它的高度都会翻倍。每年夏天，它的高度都会增加 1 米。</p><p>对于一颗在春天开始时种下的高 1 米的树，问经过指定周期后，树的高度为多少。</p><p>输入描述 输入一个数字 N\\ (0 \\leq N \\leq 1000)N (0≤N≤1000)，表示指定周期。</p><p>输出描述 输出一个数字，为经过指定周期后树的高度。</p><h3 id="题解" tabindex="-1"><a class="header-anchor" href="#题解" aria-hidden="true">#</a> 题解</h3><p>一年有两个生长周期，春天和夏天，春天长高一倍，夏天长高一米，每一年都是以春天开始的，例如输入 3 代表生长了 3 个周期，最后的高度是 6 米，因为树原本有一米，春天长了一倍后就是两米，过了一个周期，夏天长了一米后有 3 米，又过了一个周期，然后又到了春天，然后长了一倍就是 6 米。所以我们可以把春天的周期看作是奇数周期，夏天是偶数周期，轮到奇数周期就在原来的高度上增加一倍，轮到偶数周期就在原来的基础上增高一米，循环 N 就能得到最后的高度。</p><h3 id="源代码" tabindex="-1"><a class="header-anchor" href="#源代码" aria-hidden="true">#</a> 源代码</h3><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n  int N;\n  int length = 1;\n  cin &gt;&gt; N;\n\n  for(int i = 1;i &lt;= N;i++){\n    if(i&amp;1==1)          \\\\判断奇数或者是偶数的方法\n      length=length*2;\n    else\n      length=length+1;\n  }\n  cout &lt;&lt; length;\n\n  return 0;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h2 id="_2-用杂志拼接信件" tabindex="-1"><a class="header-anchor" href="#_2-用杂志拼接信件" aria-hidden="true">#</a> 2. 用杂志拼接信件</h2><h3 id="问题描述-1" tabindex="-1"><a class="header-anchor" href="#问题描述-1" aria-hidden="true">#</a> 问题描述</h3><p>实现一个算法确定能否由杂志构成信件。介绍如下：</p><p>影视剧中信件大多是从报纸或杂志上的字符剪下来拼接而成的。</p><p>杂志和信件均由字符串构成，对于给定的杂志和信件，确定信件是否可以由杂志上的字符构成。</p><p>例如杂志为 ab，信件为 aa，则不能构成。杂志为 aab，信件为 aa，则可以构成。</p><p>输入描述 输入两行字符串，长度均不超过 100。</p><p>第一行为杂志字符串，第二行为信件字符串。</p><p>输出描述 输出一行，若信件可由杂志构成则输出 YES，否则输出 NO。</p><h3 id="思路" tabindex="-1"><a class="header-anchor" href="#思路" aria-hidden="true">#</a> 思路</h3>',22),r=(0,e.Uk)("此题的一种快捷算法是直接运用函数求解，查找字符串是否有包含关系，这种方法快捷简单，能够节省时间，但是需要我们对函数的使用方法有了解。 "),i={href:"http://www.cplusplus.com/reference/string/string/find/",target:"_blank",rel:"noopener noreferrer"},p=(0,e.Uk)("find()函数的使用方法"),b=(0,e.Uk)("。 在不知道函数的情况下，我们也可以解决，b 字符串的内容包含在 a 字符串里面的，所以我们就只要逐个检验对比两个字符串的情况就可以得出结果。"),t=(0,e.uE)('<h3 id="源代码-1" tabindex="-1"><a class="header-anchor" href="#源代码-1" aria-hidden="true">#</a> 源代码</h3><hr><p><strong>直接运用函数查找</strong></p><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>#include &lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nint main()\n{\n  // 请在此输入您的代码\n  string a,b;\n  cin &gt;&gt; a;\n  cin &gt;&gt; b;\n  if(a.find(b) != string::npos) //如果字符串不存在包含关系，那么返回值就一定是npos\n    cout&lt;&lt;&quot;YES&quot;;\n  else cout&lt;&lt;&quot;NO&quot;; //k=-1说明没有找到\n  return 0;\n} \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><hr><p><strong>使用数组单独查找</strong></p><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\nint main()\n{\n    string a, b;                                \n    int c = 0, d = 0;\n    cin &gt;&gt; a &gt;&gt; b;         //需注意此处为 b字符串 在 a字符串 中查找\n    for (int i = 0; i &lt; a.length(); i++) {\n        if (a[i] == b[c])c++;\n        if (js == b.length()) {\n            d = 1;\n            break;\n        }\n    }\n    if (d == 1)\n        cout &lt;&lt; &quot;YES&quot;;\n    else cout &lt;&lt; &quot;NO&quot;;\n    return 0;\n} \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h2 id="_3-分发饼干" tabindex="-1"><a class="header-anchor" href="#_3-分发饼干" aria-hidden="true">#</a> 3. 分发饼干</h2><h3 id="问题描述-2" tabindex="-1"><a class="header-anchor" href="#问题描述-2" aria-hidden="true">#</a> 问题描述</h3><p>实现一个算法找到使最多孩子得到满足的分发饼干方法。介绍如下：</p><p>家长要将饼干分发给孩子，每个孩子有一个表示胃口的值，每个饼干有一个表示尺寸的值。如果饼干的尺寸与孩子的胃口相等或大于胃口，则将这个饼干分发给这个孩子，孩子能得到满足。</p><p>对于给定孩子及饼干的数组，需要将饼干分发给孩子，使最多的孩子得到满足。</p><p>例如孩子数组为 [1, 2, 3]，饼干数组为 [1, 1]，则将尺寸为 1 的饼干分发给胃口为 1 的孩子，这个孩子将得到满足，而另外的两个孩子无法得到满足。那么得到满足的孩子个数为 1 个。</p><h3 id="思路-1" tabindex="-1"><a class="header-anchor" href="#思路-1" aria-hidden="true">#</a> 思路</h3><p>其实就是逐个比较数组元素的大小，由于数据规模小，所以直接使用双重循环也可以。</p><h3 id="源代码-2" tabindex="-1"><a class="header-anchor" href="#源代码-2" aria-hidden="true">#</a> 源代码</h3><hr><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n  int N,M;\n  int A[1001],B[1001];\n  int count=0;\n  cin &gt;&gt; N &gt;&gt;M;\n  for(int i = 0;i&lt;N;i++){\n    cin &gt;&gt; A[i];\n  }\n  for(int i = 0;i&lt;M;i++){\n    cin &gt;&gt; B[i];\n  }\n\n  for(int i = 0;i&lt;N;i++){\n    for(int j = 0;j&lt;M;j++){\n      if(A[i] &lt;= B[j]){\n        count++;\n        break;\n      }\n    }\n  }\n  cout &lt;&lt; count;\n\n  // 请在此输入您的代码\n  return 0;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h2 id="_4-其他元素的乘积" tabindex="-1"><a class="header-anchor" href="#_4-其他元素的乘积" aria-hidden="true">#</a> 4. 其他元素的乘积</h2><h3 id="问题描述-3" tabindex="-1"><a class="header-anchor" href="#问题描述-3" aria-hidden="true">#</a> 问题描述</h3><p>给定一个数组，对于数组的每个位置，实现一个算法求数组中除当前元素的所有元素的乘积。介绍如下：</p><p>例如数组为 [0, 1, 2]，除当前元素的所有元素乘积为 [12, 02, 0*1]，结果为 [2, 0, 0]。 输入描述 第一行输入一个数字（2≤N≤10^4）。表示数组元素的个数。</p><p>第二行输入数组元素0≤A≤100。</p><p>输出描述 输出一行 N 个数字，由空格隔开，为除当前元素的所有元素的乘积。</p><h3 id="思路-2" tabindex="-1"><a class="header-anchor" href="#思路-2" aria-hidden="true">#</a> 思路</h3><p>不能使用除法，我的第一想法就是把所有元素的全部乘一遍，得到一个 sum ，然后其他元素的值就为 sum / a[i], 我还考虑了元素的范围会不会超限，但是这根本就不需要考虑，因为数组 a 里面假如出现了一个元素为 0 ，那么这个方法就行不通。所以我们需要另寻它路。</p><p>我们再引进三个数组，分别存储 a 数组的左元素乘积和右元素乘积， l[i] 表示存储数组 a[i] 左边所有元素的乘积，r[i] 表示存储a[i]右边元素的乘积。最后一个 answer 数组用于存储最后的结果。可以得到结果。</p><h3 id="源代码-3" tabindex="-1"><a class="header-anchor" href="#源代码-3" aria-hidden="true">#</a> 源代码</h3><hr><p><strong>借用三数组法</strong></p><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n  int N;\n  int a[100001];\n  int l[100001];\n  int r[100001];\n  int answer[100001];\n\n  cin &gt;&gt; N;\n\n  for(int i = 0 ;i &lt; N;i++){\n    cin &gt;&gt; a[i];\n  }\n\n  l[0]=1;\n  for(int i = 1;i &lt; N;i++){\n    l[i] = a[i-1] * l[i-1];\n  }\n  r[N-1]=1;\n  for(int i = N-2;i&gt;=0;i--){\n    r[i]= a[i+1] * r[i+1];\n  }\n  for(int i = 0;i&lt;N;i++){\n    answer[i] = l[i]*r[i];\n    cout &lt;&lt; answer[i] &lt;&lt;&quot; &quot;;\n  }\n\n  return 0;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><hr><p><strong>只借用一个数组</strong></p><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n  int N;\n  cin &gt;&gt; N;\n  int a[N],answer[N];\n\n  for(int i = 0;i &lt; N;i++){\n    cin &gt;&gt; a[i];\n  }\n\n  answer[0] = 1;\n  for (int i = 1; i &lt; N; i++) {\n    answer[i] = a[i - 1] * answer[i - 1];\n  }\n  // R 为右侧所有元素的乘积\n  // 刚开始右边没有元素，所以 R = 1\n  int R = 1;\n  for (int i = N - 1; i &gt;= 0; i--) {\n  // 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R\n  answer[i] = answer[i] * R;\n  // R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上\n  R *= a[i];\n  }\n  for(int i = 0;i&lt;N;i++){\n    cout &lt;&lt; answer[i] &lt;&lt;&quot; &quot;;\n  }\n  \n  return 0;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><h2 id="_5-寻找-3-个数的最大乘积" tabindex="-1"><a class="header-anchor" href="#_5-寻找-3-个数的最大乘积" aria-hidden="true">#</a> 5. 寻找 3 个数的最大乘积</h2><h3 id="问题描述-4" tabindex="-1"><a class="header-anchor" href="#问题描述-4" aria-hidden="true">#</a> 问题描述</h3><p>实现一个算法在数组中找到 3 个数字的最大乘积。介绍如下：</p><p>例如数组 [5, -2, 3, 1, -1, 4] 中 3 个数字的最大乘积为 60。<br> 输入描述<br> 第一行为数字 N (3≤N≤1000)，表示数组元素的个数。</p><p>第二行为数组元素 Ai -1000 &lt;= Ai &lt;= 1000<br> 输出描述<br> 输出一行，为 3 个数字的最大乘积。</p><h3 id="思路-3" tabindex="-1"><a class="header-anchor" href="#思路-3" aria-hidden="true">#</a> 思路</h3><p>对数组进行排序，把最大的三个元素找出来乘起来就行；但是这个方法在蓝桥杯的评测系统评测时，调试的时候可以通过，但是提交代码的时候就显示错误，但是其他的三重循环的居然能通过我也是不知道为什么。</p><h3 id="源代码-4" tabindex="-1"><a class="header-anchor" href="#源代码-4" aria-hidden="true">#</a> 源代码</h3><hr><p><strong>排序找最大元素</strong></p><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nvoid sort(int a[], int lo, int hi);\nint partition(int a[], int lo ,int hi);\nvoid swap(int a[], int i, int j);\n\nvoid sort(int a[], int lo, int hi){\n\tif(hi &lt;= lo) return;\n\tint j = partition(a, lo ,hi);\n\tsort(a, lo, j - 1);\n\tsort(a, j + 1, hi);\n}\n\nint partition(int a[], int lo ,int hi){\n\tint i = lo , j = hi + 1;\n\tint temp = a[lo];\n\twhile(true){\n\t\twhile(a[++i] &lt; temp &amp;&amp; i &lt; hi);\n\t\twhile(a[--j] &gt; temp);\n\t\tif(i&gt;=j) break;\n\t\tswap(a, i, j);\n\t}\n\tswap(a, lo, j);\n\treturn j;\n}\n\nvoid swap(int a[], int i, int j){\n\tint temp = a[i];\n\ta[i] = a[j];\n\ta[j] = temp;\n}\n\nint main()\n{\n  int n;\n  int a[n];\n  cin &gt;&gt; n;\n  \n  for(int i = 0;i &lt; n;i++){\n    cin &gt;&gt; a[i];\n  }\n\n  sort(a,0,n-1);\n\n  int sum = a[n-1]*a[n-2]*a[n-3];\n\n  cout &lt;&lt; sum;\n\n  return 0;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br></div></div>',45),c={},u=(0,a(3744).Z)(c,[["render",function(n,s){const a=(0,e.up)("OutboundLink");return(0,e.wg)(),(0,e.iD)(e.HY,null,[l,(0,e._)("p",null,[r,(0,e._)("a",i,[p,(0,e.Wm)(a)]),b]),t],64)}]])}}]);